<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>commands.console9 API documentation</title>
<meta name="description" content="Internal module to interact with terminal|console" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>commands.console9</code></h1>
</header>
<section id="section-intro">
<p>Internal module to interact with terminal|console</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! python3
# -*- coding: utf-8 -*-
&#34;&#34;&#34;Internal module to interact with terminal|console
&#34;&#34;&#34;
__version__ = &#34;0.11.15&#34;

import threading


class Console:
    &#34;&#34;&#34;Class to interact with terminal|console
    &#34;&#34;&#34;

    @staticmethod
    def clean():
        &#34;&#34;&#34;Wipe terminal output. Not tested on linux
        todo test on linux, make better
        &lt;br&gt;`return` None
        &#34;&#34;&#34;
        import os
        from .os9 import OS
        if OS.windows:
            os.system(&#34;cls&#34;)
        elif OS.linux:
            import shutil
            from .const9 import newline
            print(newline * shutil.get_terminal_size().lines)
        elif OS.macos:
            os.system(r&#34;clear &amp;&amp; printf &#39;\e[3J&#39;&#34;)

    @staticmethod
    def width():
        &#34;&#34;&#34;
        &lt;br&gt;`return` int width of opened console in chars
        &#34;&#34;&#34;
        import shutil
        return shutil.get_terminal_size().columns

    @staticmethod
    def height():
        &#34;&#34;&#34;
        &lt;br&gt;`return` int height of opened console in chars
        &#34;&#34;&#34;
        from .os9 import OS
        height = None
        if OS.windows:
            import shutil
            height = shutil.get_terminal_size().lines
        elif OS.unix_family:
            from .str9 import Str
            sttysize = Console.get_output(&#34;stty size&#34;)
            height = Str.get_integers(sttysize)[0]
        return int(height)

    @classmethod
    def blink(cls, width=None, height=None, symbol=&#34;#&#34;, sleep=0.5):  # pylint: disable=too-many-locals
        &#34;&#34;&#34;Print to terminal rectangle with random color. Complete shit. Arguments width and height changing size of
        terminal, works only in Windows.
        &lt;br&gt;`param width` int width of blinking rectangle
        &lt;br&gt;`param height` int height of blinking rectangle
        &lt;br&gt;`param symbol` string of characters, that fill blinking rectangle
        &lt;br&gt;`param sleep` int|float define sleep between print new colored rectangle
        &lt;br&gt;`return`
        &#34;&#34;&#34;
        import random
        from .os9 import OS
        from .print9 import Print
        from .const9 import newline
        if (width is not None) and (height is not None) and OS.windows:
            import os
            os.system(&#34;mode con cols=&#34; + str(width) + &#34; lines=&#34; + str(height))
        if width is None:
            width = cls.width()
        if height is None:
            height = cls.height()
        while True:
            colors = [&#34;grey&#34;, &#34;red&#34;, &#34;green&#34;, &#34;yellow&#34;, &#34;blue&#34;, &#34;magenta&#34;, &#34;cyan&#34;, &#34;white&#34;]
            highlights = [&#34;on_grey&#34;, &#34;on_red&#34;, &#34;on_green&#34;, &#34;on_yellow&#34;, &#34;on_blue&#34;, &#34;on_magenta&#34;, &#34;on_cyan&#34;, &#34;on_white&#34;]
            string = symbol * width
            color = random.choice(colors)
            colors.pop(colors.index(color))
            highlight = random.choice(highlights)
            try:  # New version with one long line. Works perfect, as I see.
                import time
                string = string * height
                Print.colored(newline + string, color, highlight, end = &#34;&#34;)
                time.sleep(sleep)
            except KeyboardInterrupt:
                Print.colored(&#34;OK&#34;, &#34;white&#34;, &#34;on_grey&#34;)
                cls.clean()
                break

    @staticmethod
    def _get_output(commands, print_std, decoding, pure_shell, universal_newlines, debug=False,
                    hook_stdout=None, hook_stderr=None, timeout=None):
        import subprocess
        from .threading9 import Threading

        is_string = decoding or universal_newlines

        class State:
            timeout_reached = False

        def kill_popen(popen_obj):
            State.timeout_reached = True
            popen_obj.kill()

        try:
            with subprocess.Popen(commands, shell=pure_shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                  universal_newlines=universal_newlines) as popen_object:
                def print_out_lines(obj: popen_object, stderr: bool, hook):
                    if timeout is not None:
                        timer = threading.Timer(timeout, kill_popen, args=[popen_object])
                        timer.start()
                    color = &#34;red&#34; if stderr else &#34;green&#34;
                    output = b&#39;&#39;
                    if is_string:
                        output = &#39;&#39;
                    finished = False
                    # for string in obj:
                    while not finished:
                        string_input = b&#39;&#39;
                        while True:
                            sym = obj.read(1)
                            if not sym:
                                finished = True
                                break
                            string_input += sym
                            if sym in [b&#39;\r&#39;, b&#39;\n&#39;]:
                                break
                        string_current = string_input
                        if decoding:
                            try:
                                string_current = string_input.decode(decoding)
                            except UnicodeDecodeError:
                                # fallback to chardet
                                import chardet
                                string_current = string_input.decode(chardet.detect(string_input)[&#39;encoding&#39;])
                        hook(string_current)
                        output += string_current
                        if print_std:
                            from .print9 import Print
                            Print.colored(string_current, color, end=&#39;&#39;, flush=True)
                    if timeout is not None:
                        timer.cancel()
                    return output

                pipes = Threading(verbose=debug)

                pipes.add(print_out_lines, &#34;stdout&#34;,
                          kwargs={&#34;obj&#34;: popen_object.stdout,
                                  &#34;stderr&#34;: False,
                                  &#34;hook&#34;: hook_stdout})
                pipes.add(print_out_lines, &#34;stderr&#34;,
                          kwargs={&#34;obj&#34;: popen_object.stderr,
                                  &#34;stderr&#34;: True,
                                  &#34;hook&#34;: hook_stderr})

                pipes.start(wait_for_keyboard_interrupt=True)

                out, err = pipes.get_results()

        except FileNotFoundError as exception:
            if debug:
                from .print9 import Print
                Print.debug(&#34;commands&#34;, commands,
                            &#34;pure_shell&#34;, pure_shell,
                            &#34;print_std&#34;, print_std,
                            &#34;decoding&#34;, decoding,
                            &#34;universal_newlines&#34;, universal_newlines)
            raise FileNotFoundError(exception)
        return out, err, State.timeout_reached

    windows_cp65001 = False
    windows_cp65001_fail = False

    @classmethod
    def get_output(cls, *commands, pure_shell=False, print_std=False, decoding=None, universal_newlines=False,
                   auto_decoding=True, auto_disable_py_buffering=True, return_merged=True, timeout=None, debug=False,
                   create_cmd_subprocess=False, hook_stdout=None, hook_stderr=None):
        &#34;&#34;&#34;Return output of executing command.
        &lt;br&gt;`param commands` list[string if pure_shell is True] with command and arguments
        &lt;br&gt;`param pure_shell` boolean, if True, the specified command will be executed through the shell
        &lt;br&gt;`param print_std` boolean, if True, output from command will be printed immediately
            (also adds argument -u to
        &#39;py&#39; or &#39;python&#39; firs arg.)
        &lt;br&gt;`return` tuple with strings stdout and stderr
        &#34;&#34;&#34;
        import os
        from .os9 import OS
        if len(commands) == 1:
            commands = commands[0]
        if isinstance(commands, str) and not pure_shell:
            import shlex
            commands = shlex.split(commands, posix=False)

        if isinstance(commands, list) or isinstance(commands, tuple):
            from .list9 import List
            commands = List.to_strings(commands)

        if not commands:
            raise IndexError(&#34;commands must not be empty&#34;)

        def empty_hook(_):
            pass

        if hook_stdout is None:
            hook_stdout = empty_hook
        if hook_stderr is None:
            hook_stderr = empty_hook

        # disable buffering for python
        if (&#34;py&#34; in commands
            or &#34;py&#34; in os.path.split(commands[0])[1]
            or &#34;python&#34; in commands
            or &#34;python&#34; in os.path.split(commands[0])[1]
            or &#34;python3&#34; in commands
            or &#34;python3&#34; in os.path.split(commands[0])[1]
        ) and print_std and auto_disable_py_buffering:
            if &#34;-u&#34; not in commands:
                list_commands = list(commands)
                list_commands.insert(1, &#34;-u&#34;)
                commands = list_commands
        # set decoding and init
        if auto_decoding and not decoding and not universal_newlines:
            if OS.windows:
                if cls.windows_cp65001:
                    decoding = &#34;cp65001&#34;
                elif cls.windows_cp65001_fail:
                    decoding = &#34;cp866&#34;
                else:
                    from .windows9 import Windows
                    try:
                        Windows.fix_unicode_encode_error(safe=False)
                        cls.windows_cp65001 = True
                        decoding = &#34;cp65001&#34;
                    except IOError:  # if cp65001 cannot be set
                        cls.windows_cp65001_fail = True
                        decoding = f&#34;cp{Windows.get_cmd_code_page()}&#34;
            elif OS.unix_family:
                decoding = &#34;utf8&#34;
            else:
                universal_newlines = True

        if decoding and universal_newlines:
            raise TypeError(&#34;can&#39;t decode &#39;str&#39; to &#39;str&#39;, set universal_newlines to False for manually set decoding&#34;)

        if create_cmd_subprocess:
            commands_old = commands
            commands = list()
            commands.append(&#34;cmd&#34;)
            # commands.append(&#34;/U&#34;)  # only cmd applications output in utf16,
            #                          other applications output in default encoding D:
            commands.append(&#34;/C&#34;)
            commands.append(&#34; &#34;.join(commands_old))

        out, err, timeout_reached = cls._get_output(commands, print_std=print_std, decoding=decoding,
                                                    pure_shell=pure_shell,
                                                    universal_newlines=universal_newlines, debug=debug,
                                                    hook_stdout=hook_stdout,
                                                    hook_stderr=hook_stderr,
                                                    timeout=timeout)
        if return_merged:
            return out + err
        if timeout:
            return out, err, timeout_reached
        else:
            return out, err

    @classmethod
    def fit(cls, *strings: str, sep: str = &#34; &#34;, reverse=False):
        &#34;&#34;&#34;Fit strings to console
        &lt;br&gt;`param strings` list of strings
        &lt;br&gt;`param sep` string to join strings
        &lt;br&gt;`param reverse` boolean, if True, cut from end of string
        &lt;br&gt;`return` strings, that can be fit in one line print
        &lt;br&gt; yes, implementation is far beyond good
        &#34;&#34;&#34;
        from .os9 import OS
        from .list9 import List
        from wcwidth import wcswidth

        console_width = cls.width()
        
        if OS.windows:  # windows adds symbol to end of string :(
            console_width -= 1
        strings = List.to_strings(strings)  # replace all to strings
        len_all = wcswidth(sep.join(strings))  # count len of all
        reverse = not reverse
        prefix = &#34;&gt;&gt;&#34; if reverse else &#34;&lt;&lt;&#34;
        
        # check for fit
        if len_all &lt;= console_width:
            pass
        else:
            # get the longest line
            longest_string_index = 0
            for cnt, string in enumerate(strings):
                if wcswidth(string) &gt; wcswidth(strings[longest_string_index]):
                    longest_string_index = cnt
            longest_string = strings[longest_string_index]
            
            # cut line
            cut_cnt = len_all - console_width + wcswidth(prefix)
            desired_length = wcswidth(longest_string) - cut_cnt
            lendiff = wcswidth(longest_string) - len(longest_string)  # add buffer for double characters
            if reverse:
                longest_string = longest_string[::-1]

            longest_string = longest_string[:int(-cut_cnt+lendiff)]
            
            while wcswidth(longest_string) &gt; desired_length:
                longest_string = longest_string[:-1]

            while wcswidth(longest_string) &lt; desired_length:
                longest_string += &#34; &#34;

            longest_string += prefix

            if reverse:
                longest_string = longest_string[::-1]

            
            strings[longest_string_index] = longest_string

        return strings</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="commands.console9.Console"><code class="flex name class">
<span>class <span class="ident">Console</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class to interact with terminal|console</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Console:
    &#34;&#34;&#34;Class to interact with terminal|console
    &#34;&#34;&#34;

    @staticmethod
    def clean():
        &#34;&#34;&#34;Wipe terminal output. Not tested on linux
        todo test on linux, make better
        &lt;br&gt;`return` None
        &#34;&#34;&#34;
        import os
        from .os9 import OS
        if OS.windows:
            os.system(&#34;cls&#34;)
        elif OS.linux:
            import shutil
            from .const9 import newline
            print(newline * shutil.get_terminal_size().lines)
        elif OS.macos:
            os.system(r&#34;clear &amp;&amp; printf &#39;\e[3J&#39;&#34;)

    @staticmethod
    def width():
        &#34;&#34;&#34;
        &lt;br&gt;`return` int width of opened console in chars
        &#34;&#34;&#34;
        import shutil
        return shutil.get_terminal_size().columns

    @staticmethod
    def height():
        &#34;&#34;&#34;
        &lt;br&gt;`return` int height of opened console in chars
        &#34;&#34;&#34;
        from .os9 import OS
        height = None
        if OS.windows:
            import shutil
            height = shutil.get_terminal_size().lines
        elif OS.unix_family:
            from .str9 import Str
            sttysize = Console.get_output(&#34;stty size&#34;)
            height = Str.get_integers(sttysize)[0]
        return int(height)

    @classmethod
    def blink(cls, width=None, height=None, symbol=&#34;#&#34;, sleep=0.5):  # pylint: disable=too-many-locals
        &#34;&#34;&#34;Print to terminal rectangle with random color. Complete shit. Arguments width and height changing size of
        terminal, works only in Windows.
        &lt;br&gt;`param width` int width of blinking rectangle
        &lt;br&gt;`param height` int height of blinking rectangle
        &lt;br&gt;`param symbol` string of characters, that fill blinking rectangle
        &lt;br&gt;`param sleep` int|float define sleep between print new colored rectangle
        &lt;br&gt;`return`
        &#34;&#34;&#34;
        import random
        from .os9 import OS
        from .print9 import Print
        from .const9 import newline
        if (width is not None) and (height is not None) and OS.windows:
            import os
            os.system(&#34;mode con cols=&#34; + str(width) + &#34; lines=&#34; + str(height))
        if width is None:
            width = cls.width()
        if height is None:
            height = cls.height()
        while True:
            colors = [&#34;grey&#34;, &#34;red&#34;, &#34;green&#34;, &#34;yellow&#34;, &#34;blue&#34;, &#34;magenta&#34;, &#34;cyan&#34;, &#34;white&#34;]
            highlights = [&#34;on_grey&#34;, &#34;on_red&#34;, &#34;on_green&#34;, &#34;on_yellow&#34;, &#34;on_blue&#34;, &#34;on_magenta&#34;, &#34;on_cyan&#34;, &#34;on_white&#34;]
            string = symbol * width
            color = random.choice(colors)
            colors.pop(colors.index(color))
            highlight = random.choice(highlights)
            try:  # New version with one long line. Works perfect, as I see.
                import time
                string = string * height
                Print.colored(newline + string, color, highlight, end = &#34;&#34;)
                time.sleep(sleep)
            except KeyboardInterrupt:
                Print.colored(&#34;OK&#34;, &#34;white&#34;, &#34;on_grey&#34;)
                cls.clean()
                break

    @staticmethod
    def _get_output(commands, print_std, decoding, pure_shell, universal_newlines, debug=False,
                    hook_stdout=None, hook_stderr=None, timeout=None):
        import subprocess
        from .threading9 import Threading

        is_string = decoding or universal_newlines

        class State:
            timeout_reached = False

        def kill_popen(popen_obj):
            State.timeout_reached = True
            popen_obj.kill()

        try:
            with subprocess.Popen(commands, shell=pure_shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                  universal_newlines=universal_newlines) as popen_object:
                def print_out_lines(obj: popen_object, stderr: bool, hook):
                    if timeout is not None:
                        timer = threading.Timer(timeout, kill_popen, args=[popen_object])
                        timer.start()
                    color = &#34;red&#34; if stderr else &#34;green&#34;
                    output = b&#39;&#39;
                    if is_string:
                        output = &#39;&#39;
                    finished = False
                    # for string in obj:
                    while not finished:
                        string_input = b&#39;&#39;
                        while True:
                            sym = obj.read(1)
                            if not sym:
                                finished = True
                                break
                            string_input += sym
                            if sym in [b&#39;\r&#39;, b&#39;\n&#39;]:
                                break
                        string_current = string_input
                        if decoding:
                            try:
                                string_current = string_input.decode(decoding)
                            except UnicodeDecodeError:
                                # fallback to chardet
                                import chardet
                                string_current = string_input.decode(chardet.detect(string_input)[&#39;encoding&#39;])
                        hook(string_current)
                        output += string_current
                        if print_std:
                            from .print9 import Print
                            Print.colored(string_current, color, end=&#39;&#39;, flush=True)
                    if timeout is not None:
                        timer.cancel()
                    return output

                pipes = Threading(verbose=debug)

                pipes.add(print_out_lines, &#34;stdout&#34;,
                          kwargs={&#34;obj&#34;: popen_object.stdout,
                                  &#34;stderr&#34;: False,
                                  &#34;hook&#34;: hook_stdout})
                pipes.add(print_out_lines, &#34;stderr&#34;,
                          kwargs={&#34;obj&#34;: popen_object.stderr,
                                  &#34;stderr&#34;: True,
                                  &#34;hook&#34;: hook_stderr})

                pipes.start(wait_for_keyboard_interrupt=True)

                out, err = pipes.get_results()

        except FileNotFoundError as exception:
            if debug:
                from .print9 import Print
                Print.debug(&#34;commands&#34;, commands,
                            &#34;pure_shell&#34;, pure_shell,
                            &#34;print_std&#34;, print_std,
                            &#34;decoding&#34;, decoding,
                            &#34;universal_newlines&#34;, universal_newlines)
            raise FileNotFoundError(exception)
        return out, err, State.timeout_reached

    windows_cp65001 = False
    windows_cp65001_fail = False

    @classmethod
    def get_output(cls, *commands, pure_shell=False, print_std=False, decoding=None, universal_newlines=False,
                   auto_decoding=True, auto_disable_py_buffering=True, return_merged=True, timeout=None, debug=False,
                   create_cmd_subprocess=False, hook_stdout=None, hook_stderr=None):
        &#34;&#34;&#34;Return output of executing command.
        &lt;br&gt;`param commands` list[string if pure_shell is True] with command and arguments
        &lt;br&gt;`param pure_shell` boolean, if True, the specified command will be executed through the shell
        &lt;br&gt;`param print_std` boolean, if True, output from command will be printed immediately
            (also adds argument -u to
        &#39;py&#39; or &#39;python&#39; firs arg.)
        &lt;br&gt;`return` tuple with strings stdout and stderr
        &#34;&#34;&#34;
        import os
        from .os9 import OS
        if len(commands) == 1:
            commands = commands[0]
        if isinstance(commands, str) and not pure_shell:
            import shlex
            commands = shlex.split(commands, posix=False)

        if isinstance(commands, list) or isinstance(commands, tuple):
            from .list9 import List
            commands = List.to_strings(commands)

        if not commands:
            raise IndexError(&#34;commands must not be empty&#34;)

        def empty_hook(_):
            pass

        if hook_stdout is None:
            hook_stdout = empty_hook
        if hook_stderr is None:
            hook_stderr = empty_hook

        # disable buffering for python
        if (&#34;py&#34; in commands
            or &#34;py&#34; in os.path.split(commands[0])[1]
            or &#34;python&#34; in commands
            or &#34;python&#34; in os.path.split(commands[0])[1]
            or &#34;python3&#34; in commands
            or &#34;python3&#34; in os.path.split(commands[0])[1]
        ) and print_std and auto_disable_py_buffering:
            if &#34;-u&#34; not in commands:
                list_commands = list(commands)
                list_commands.insert(1, &#34;-u&#34;)
                commands = list_commands
        # set decoding and init
        if auto_decoding and not decoding and not universal_newlines:
            if OS.windows:
                if cls.windows_cp65001:
                    decoding = &#34;cp65001&#34;
                elif cls.windows_cp65001_fail:
                    decoding = &#34;cp866&#34;
                else:
                    from .windows9 import Windows
                    try:
                        Windows.fix_unicode_encode_error(safe=False)
                        cls.windows_cp65001 = True
                        decoding = &#34;cp65001&#34;
                    except IOError:  # if cp65001 cannot be set
                        cls.windows_cp65001_fail = True
                        decoding = f&#34;cp{Windows.get_cmd_code_page()}&#34;
            elif OS.unix_family:
                decoding = &#34;utf8&#34;
            else:
                universal_newlines = True

        if decoding and universal_newlines:
            raise TypeError(&#34;can&#39;t decode &#39;str&#39; to &#39;str&#39;, set universal_newlines to False for manually set decoding&#34;)

        if create_cmd_subprocess:
            commands_old = commands
            commands = list()
            commands.append(&#34;cmd&#34;)
            # commands.append(&#34;/U&#34;)  # only cmd applications output in utf16,
            #                          other applications output in default encoding D:
            commands.append(&#34;/C&#34;)
            commands.append(&#34; &#34;.join(commands_old))

        out, err, timeout_reached = cls._get_output(commands, print_std=print_std, decoding=decoding,
                                                    pure_shell=pure_shell,
                                                    universal_newlines=universal_newlines, debug=debug,
                                                    hook_stdout=hook_stdout,
                                                    hook_stderr=hook_stderr,
                                                    timeout=timeout)
        if return_merged:
            return out + err
        if timeout:
            return out, err, timeout_reached
        else:
            return out, err

    @classmethod
    def fit(cls, *strings: str, sep: str = &#34; &#34;, reverse=False):
        &#34;&#34;&#34;Fit strings to console
        &lt;br&gt;`param strings` list of strings
        &lt;br&gt;`param sep` string to join strings
        &lt;br&gt;`param reverse` boolean, if True, cut from end of string
        &lt;br&gt;`return` strings, that can be fit in one line print
        &lt;br&gt; yes, implementation is far beyond good
        &#34;&#34;&#34;
        from .os9 import OS
        from .list9 import List
        from wcwidth import wcswidth

        console_width = cls.width()
        
        if OS.windows:  # windows adds symbol to end of string :(
            console_width -= 1
        strings = List.to_strings(strings)  # replace all to strings
        len_all = wcswidth(sep.join(strings))  # count len of all
        reverse = not reverse
        prefix = &#34;&gt;&gt;&#34; if reverse else &#34;&lt;&lt;&#34;
        
        # check for fit
        if len_all &lt;= console_width:
            pass
        else:
            # get the longest line
            longest_string_index = 0
            for cnt, string in enumerate(strings):
                if wcswidth(string) &gt; wcswidth(strings[longest_string_index]):
                    longest_string_index = cnt
            longest_string = strings[longest_string_index]
            
            # cut line
            cut_cnt = len_all - console_width + wcswidth(prefix)
            desired_length = wcswidth(longest_string) - cut_cnt
            lendiff = wcswidth(longest_string) - len(longest_string)  # add buffer for double characters
            if reverse:
                longest_string = longest_string[::-1]

            longest_string = longest_string[:int(-cut_cnt+lendiff)]
            
            while wcswidth(longest_string) &gt; desired_length:
                longest_string = longest_string[:-1]

            while wcswidth(longest_string) &lt; desired_length:
                longest_string += &#34; &#34;

            longest_string += prefix

            if reverse:
                longest_string = longest_string[::-1]

            
            strings[longest_string_index] = longest_string

        return strings</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="commands.console9.Console.windows_cp65001"><code class="name">var <span class="ident">windows_cp65001</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="commands.console9.Console.windows_cp65001_fail"><code class="name">var <span class="ident">windows_cp65001_fail</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="commands.console9.Console.blink"><code class="name flex">
<span>def <span class="ident">blink</span></span>(<span>width=None, height=None, symbol='#', sleep=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Print to terminal rectangle with random color. Complete shit. Arguments width and height changing size of
terminal, works only in Windows.
<br><code>param width</code> int width of blinking rectangle
<br><code>param height</code> int height of blinking rectangle
<br><code>param symbol</code> string of characters, that fill blinking rectangle
<br><code>param sleep</code> int|float define sleep between print new colored rectangle
<br><code>return</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def blink(cls, width=None, height=None, symbol=&#34;#&#34;, sleep=0.5):  # pylint: disable=too-many-locals
    &#34;&#34;&#34;Print to terminal rectangle with random color. Complete shit. Arguments width and height changing size of
    terminal, works only in Windows.
    &lt;br&gt;`param width` int width of blinking rectangle
    &lt;br&gt;`param height` int height of blinking rectangle
    &lt;br&gt;`param symbol` string of characters, that fill blinking rectangle
    &lt;br&gt;`param sleep` int|float define sleep between print new colored rectangle
    &lt;br&gt;`return`
    &#34;&#34;&#34;
    import random
    from .os9 import OS
    from .print9 import Print
    from .const9 import newline
    if (width is not None) and (height is not None) and OS.windows:
        import os
        os.system(&#34;mode con cols=&#34; + str(width) + &#34; lines=&#34; + str(height))
    if width is None:
        width = cls.width()
    if height is None:
        height = cls.height()
    while True:
        colors = [&#34;grey&#34;, &#34;red&#34;, &#34;green&#34;, &#34;yellow&#34;, &#34;blue&#34;, &#34;magenta&#34;, &#34;cyan&#34;, &#34;white&#34;]
        highlights = [&#34;on_grey&#34;, &#34;on_red&#34;, &#34;on_green&#34;, &#34;on_yellow&#34;, &#34;on_blue&#34;, &#34;on_magenta&#34;, &#34;on_cyan&#34;, &#34;on_white&#34;]
        string = symbol * width
        color = random.choice(colors)
        colors.pop(colors.index(color))
        highlight = random.choice(highlights)
        try:  # New version with one long line. Works perfect, as I see.
            import time
            string = string * height
            Print.colored(newline + string, color, highlight, end = &#34;&#34;)
            time.sleep(sleep)
        except KeyboardInterrupt:
            Print.colored(&#34;OK&#34;, &#34;white&#34;, &#34;on_grey&#34;)
            cls.clean()
            break</code></pre>
</details>
</dd>
<dt id="commands.console9.Console.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wipe terminal output. Not tested on linux
todo test on linux, make better
<br><code>return</code> None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def clean():
    &#34;&#34;&#34;Wipe terminal output. Not tested on linux
    todo test on linux, make better
    &lt;br&gt;`return` None
    &#34;&#34;&#34;
    import os
    from .os9 import OS
    if OS.windows:
        os.system(&#34;cls&#34;)
    elif OS.linux:
        import shutil
        from .const9 import newline
        print(newline * shutil.get_terminal_size().lines)
    elif OS.macos:
        os.system(r&#34;clear &amp;&amp; printf &#39;\e[3J&#39;&#34;)</code></pre>
</details>
</dd>
<dt id="commands.console9.Console.fit"><code class="name flex">
<span>def <span class="ident">fit</span></span>(<span>*strings: str, sep: str = ' ', reverse=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Fit strings to console
<br><code>param strings</code> list of strings
<br><code>param sep</code> string to join strings
<br><code>param reverse</code> boolean, if True, cut from end of string
<br><code>return</code> strings, that can be fit in one line print
<br> yes, implementation is far beyond good</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fit(cls, *strings: str, sep: str = &#34; &#34;, reverse=False):
    &#34;&#34;&#34;Fit strings to console
    &lt;br&gt;`param strings` list of strings
    &lt;br&gt;`param sep` string to join strings
    &lt;br&gt;`param reverse` boolean, if True, cut from end of string
    &lt;br&gt;`return` strings, that can be fit in one line print
    &lt;br&gt; yes, implementation is far beyond good
    &#34;&#34;&#34;
    from .os9 import OS
    from .list9 import List
    from wcwidth import wcswidth

    console_width = cls.width()
    
    if OS.windows:  # windows adds symbol to end of string :(
        console_width -= 1
    strings = List.to_strings(strings)  # replace all to strings
    len_all = wcswidth(sep.join(strings))  # count len of all
    reverse = not reverse
    prefix = &#34;&gt;&gt;&#34; if reverse else &#34;&lt;&lt;&#34;
    
    # check for fit
    if len_all &lt;= console_width:
        pass
    else:
        # get the longest line
        longest_string_index = 0
        for cnt, string in enumerate(strings):
            if wcswidth(string) &gt; wcswidth(strings[longest_string_index]):
                longest_string_index = cnt
        longest_string = strings[longest_string_index]
        
        # cut line
        cut_cnt = len_all - console_width + wcswidth(prefix)
        desired_length = wcswidth(longest_string) - cut_cnt
        lendiff = wcswidth(longest_string) - len(longest_string)  # add buffer for double characters
        if reverse:
            longest_string = longest_string[::-1]

        longest_string = longest_string[:int(-cut_cnt+lendiff)]
        
        while wcswidth(longest_string) &gt; desired_length:
            longest_string = longest_string[:-1]

        while wcswidth(longest_string) &lt; desired_length:
            longest_string += &#34; &#34;

        longest_string += prefix

        if reverse:
            longest_string = longest_string[::-1]

        
        strings[longest_string_index] = longest_string

    return strings</code></pre>
</details>
</dd>
<dt id="commands.console9.Console.get_output"><code class="name flex">
<span>def <span class="ident">get_output</span></span>(<span>*commands, pure_shell=False, print_std=False, decoding=None, universal_newlines=False, auto_decoding=True, auto_disable_py_buffering=True, return_merged=True, timeout=None, debug=False, create_cmd_subprocess=False, hook_stdout=None, hook_stderr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return output of executing command.
<br><code>param <a title="commands" href="index.html">commands</a></code> list[string if pure_shell is True] with command and arguments
<br><code>param pure_shell</code> boolean, if True, the specified command will be executed through the shell
<br><code>param print_std</code> boolean, if True, output from command will be printed immediately
(also adds argument -u to
'py' or 'python' firs arg.)
<br><code>return</code> tuple with strings stdout and stderr</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_output(cls, *commands, pure_shell=False, print_std=False, decoding=None, universal_newlines=False,
               auto_decoding=True, auto_disable_py_buffering=True, return_merged=True, timeout=None, debug=False,
               create_cmd_subprocess=False, hook_stdout=None, hook_stderr=None):
    &#34;&#34;&#34;Return output of executing command.
    &lt;br&gt;`param commands` list[string if pure_shell is True] with command and arguments
    &lt;br&gt;`param pure_shell` boolean, if True, the specified command will be executed through the shell
    &lt;br&gt;`param print_std` boolean, if True, output from command will be printed immediately
        (also adds argument -u to
    &#39;py&#39; or &#39;python&#39; firs arg.)
    &lt;br&gt;`return` tuple with strings stdout and stderr
    &#34;&#34;&#34;
    import os
    from .os9 import OS
    if len(commands) == 1:
        commands = commands[0]
    if isinstance(commands, str) and not pure_shell:
        import shlex
        commands = shlex.split(commands, posix=False)

    if isinstance(commands, list) or isinstance(commands, tuple):
        from .list9 import List
        commands = List.to_strings(commands)

    if not commands:
        raise IndexError(&#34;commands must not be empty&#34;)

    def empty_hook(_):
        pass

    if hook_stdout is None:
        hook_stdout = empty_hook
    if hook_stderr is None:
        hook_stderr = empty_hook

    # disable buffering for python
    if (&#34;py&#34; in commands
        or &#34;py&#34; in os.path.split(commands[0])[1]
        or &#34;python&#34; in commands
        or &#34;python&#34; in os.path.split(commands[0])[1]
        or &#34;python3&#34; in commands
        or &#34;python3&#34; in os.path.split(commands[0])[1]
    ) and print_std and auto_disable_py_buffering:
        if &#34;-u&#34; not in commands:
            list_commands = list(commands)
            list_commands.insert(1, &#34;-u&#34;)
            commands = list_commands
    # set decoding and init
    if auto_decoding and not decoding and not universal_newlines:
        if OS.windows:
            if cls.windows_cp65001:
                decoding = &#34;cp65001&#34;
            elif cls.windows_cp65001_fail:
                decoding = &#34;cp866&#34;
            else:
                from .windows9 import Windows
                try:
                    Windows.fix_unicode_encode_error(safe=False)
                    cls.windows_cp65001 = True
                    decoding = &#34;cp65001&#34;
                except IOError:  # if cp65001 cannot be set
                    cls.windows_cp65001_fail = True
                    decoding = f&#34;cp{Windows.get_cmd_code_page()}&#34;
        elif OS.unix_family:
            decoding = &#34;utf8&#34;
        else:
            universal_newlines = True

    if decoding and universal_newlines:
        raise TypeError(&#34;can&#39;t decode &#39;str&#39; to &#39;str&#39;, set universal_newlines to False for manually set decoding&#34;)

    if create_cmd_subprocess:
        commands_old = commands
        commands = list()
        commands.append(&#34;cmd&#34;)
        # commands.append(&#34;/U&#34;)  # only cmd applications output in utf16,
        #                          other applications output in default encoding D:
        commands.append(&#34;/C&#34;)
        commands.append(&#34; &#34;.join(commands_old))

    out, err, timeout_reached = cls._get_output(commands, print_std=print_std, decoding=decoding,
                                                pure_shell=pure_shell,
                                                universal_newlines=universal_newlines, debug=debug,
                                                hook_stdout=hook_stdout,
                                                hook_stderr=hook_stderr,
                                                timeout=timeout)
    if return_merged:
        return out + err
    if timeout:
        return out, err, timeout_reached
    else:
        return out, err</code></pre>
</details>
</dd>
<dt id="commands.console9.Console.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p><br><code>return</code> int height of opened console in chars</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def height():
    &#34;&#34;&#34;
    &lt;br&gt;`return` int height of opened console in chars
    &#34;&#34;&#34;
    from .os9 import OS
    height = None
    if OS.windows:
        import shutil
        height = shutil.get_terminal_size().lines
    elif OS.unix_family:
        from .str9 import Str
        sttysize = Console.get_output(&#34;stty size&#34;)
        height = Str.get_integers(sttysize)[0]
    return int(height)</code></pre>
</details>
</dd>
<dt id="commands.console9.Console.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p><br><code>return</code> int width of opened console in chars</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def width():
    &#34;&#34;&#34;
    &lt;br&gt;`return` int width of opened console in chars
    &#34;&#34;&#34;
    import shutil
    return shutil.get_terminal_size().columns</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="commands" href="index.html">commands</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="commands.console9.Console" href="#commands.console9.Console">Console</a></code></h4>
<ul class="">
<li><code><a title="commands.console9.Console.blink" href="#commands.console9.Console.blink">blink</a></code></li>
<li><code><a title="commands.console9.Console.clean" href="#commands.console9.Console.clean">clean</a></code></li>
<li><code><a title="commands.console9.Console.fit" href="#commands.console9.Console.fit">fit</a></code></li>
<li><code><a title="commands.console9.Console.get_output" href="#commands.console9.Console.get_output">get_output</a></code></li>
<li><code><a title="commands.console9.Console.height" href="#commands.console9.Console.height">height</a></code></li>
<li><code><a title="commands.console9.Console.width" href="#commands.console9.Console.width">width</a></code></li>
<li><code><a title="commands.console9.Console.windows_cp65001" href="#commands.console9.Console.windows_cp65001">windows_cp65001</a></code></li>
<li><code><a title="commands.console9.Console.windows_cp65001_fail" href="#commands.console9.Console.windows_cp65001_fail">windows_cp65001_fail</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>